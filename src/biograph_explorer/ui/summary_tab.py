"""Summary tab UI components for LLM-generated category summaries.

This module provides the UI for displaying citation-based summaries
generated by Claude Haiku 4, with interactive citation viewers.
"""

import logging
import os
import re
from typing import List, Dict

import networkx as nx
import streamlit as st

from biograph_explorer.core.llm_summarizer import LLMSummarizer, SummaryData, CitationGraph

logger = logging.getLogger(__name__)


def render_summary_tab(
    graph: nx.MultiDiGraph,
    query_genes: List[str],
    disease_curie: str,
    infores_metadata: Dict
):
    """Render Summary tab with category summaries and citation viewers.

    Args:
        graph: Knowledge graph
        query_genes: Input gene CURIEs
        disease_curie: Target disease CURIE
        infores_metadata: Knowledge source metadata
    """
    api_key = os.environ.get('ANTHROPIC_API_KEY')

    if not api_key:
        st.warning("âš ï¸ LLM Summary requires ANTHROPIC_API_KEY. Add it to your .env file.")
        st.info("Get your API key from: https://console.anthropic.com/")
        st.code("cp .env.example .env\n# Then add: ANTHROPIC_API_KEY=sk-ant-...", language="bash")
        return

    st.markdown("#### :material/auto_awesome: LLM-Generated Category Summaries")
    st.caption("Citation-based summaries with verifiable evidence from the knowledge graph")

    # Get intermediate categories
    categories = _get_intermediate_categories(graph, query_genes)

    if not categories:
        st.warning("No intermediate categories found in graph")
        return

    # Category selector
    selected_categories = st.multiselect(
        "Select Categories to Summarize",
        options=categories,
        default=categories,
        help="Choose which node categories to generate summaries for"
    )

    # Generate button with cost estimate
    col1, col2 = st.columns([1, 4])
    with col1:
        generate_btn = st.button(
            "Generate Summaries",
            disabled=len(selected_categories) == 0,
            type="primary"
        )
    with col2:
        if len(selected_categories) > 0:
            estimated_cost = 0.003 * len(selected_categories)
            st.caption(f"ðŸ’° Estimated cost: ~${estimated_cost:.3f} ({len(selected_categories)} categories Ã— $0.003)")

    # Generate summaries
    if generate_btn:
        summarizer = LLMSummarizer()
        logger.info(f"Starting LLM summary generation for {len(selected_categories)} categories")
        progress_bar = st.progress(0)
        status = st.empty()

        for i, category in enumerate(selected_categories):
            status.markdown(f"ðŸ¤– Generating summary for **{category}**...")

            try:
                summary_data = summarizer.generate_category_summary(
                    graph=graph,
                    category=category,
                    query_genes=query_genes,
                    disease_curie=disease_curie,
                    infores_metadata=infores_metadata
                )

                # Show if cached or newly generated
                was_cached = summary_data.metadata.get('from_cache', False)
                cache_indicator = "ðŸ’¾" if was_cached else "âœ¨"

                st.session_state.summaries[category] = summary_data
                logger.info(f"{'Loaded cached' if was_cached else 'Generated'} summary for {category}: {len(summary_data.citations)} citations")
                status.markdown(f"{cache_indicator} **{category}** {'(cached)' if was_cached else '(generated)'}")

            except Exception as e:
                logger.error(f"Failed to generate summary for {category}: {e}")
                st.error(f"âŒ Failed to generate summary for {category}: {e}")

            progress_bar.progress((i + 1) / len(selected_categories))

        status.markdown("âœ… All summaries generated!")
        st.rerun()

    # Display existing summaries
    if st.session_state.summaries:
        st.divider()

        for category, summary_data in st.session_state.summaries.items():
            render_category_summary(category, summary_data, graph, query_genes)


def _get_intermediate_categories(graph: nx.MultiDiGraph, query_genes: List[str]) -> List[str]:
    """Extract intermediate node categories from graph.

    Args:
        graph: Knowledge graph
        query_genes: Query gene CURIEs

    Returns:
        List of category names, sorted
    """
    categories = set()

    for node, data in graph.nodes(data=True):
        category = data.get('category')
        # Check if it's actually intermediate (connected to query genes)
        neighbors = set(graph.predecessors(node)) | set(graph.successors(node))
        if any(n in query_genes for n in neighbors):
            categories.add(category)

    return sorted(categories)


def render_category_summary(category: str, summary_data: SummaryData, graph: nx.MultiDiGraph, query_genes: List[str]):
    """Render summary for a single category.

    Args:
        category: Category name
        summary_data: Summary data with citations
        graph: Full knowledge graph
        query_genes: Input gene CURIEs for pathway display
    """
    with st.expander(f"ðŸ“Š {category}", expanded=True):
        # Metadata row
        col1, col2, col3 = st.columns(3)
        with col1:
            st.metric("Citations", len(summary_data.citations), border=True)
        with col2:
            nodes_total = summary_data.metadata.get('nodes_total', 0)
            nodes_sampled = summary_data.metadata.get('nodes_sampled', 0)
            sampling = summary_data.metadata.get('sampling_strategy', 'unknown')

            sampling_labels = {
                'full': 'Full Context',
                'medium_sample': 'Medium Sample',
                'large_sample': 'Large Sample'
            }

            st.metric(
                "Nodes Analyzed",
                f"{nodes_sampled} / {nodes_total}",
                help=f"Sampling: {sampling_labels.get(sampling, 'Unknown')}",
                border=True
            )
        with col3:
            timestamp = summary_data.metadata.get('timestamp', '')
            if timestamp:
                st.caption(f"Generated: {timestamp[:10]}")

        # Convert citation markers to clickable links
        summary_with_links = _convert_citations_to_links(summary_data.summary_text, category)
        st.markdown(summary_with_links, unsafe_allow_html=True)

        # Citations section
        if summary_data.citations:
            st.markdown("##### Citations")

            for citation in summary_data.citations:
                render_citation_card(citation, category, graph, query_genes)


def _convert_citations_to_links(summary_text: str, category: str) -> str:
    """Convert [Citation N] markers to clickable HTML anchors.

    Args:
        summary_text: Summary text with citation markers
        category: Category name for unique anchors

    Returns:
        HTML string with clickable citation links
    """
    def replace_citation(match):
        citation_num = match.group(1)
        anchor_id = f"citation_{category}_{citation_num}"
        return f'<a href="#{anchor_id}" style="color: #FF6B6B; text-decoration: none; font-weight: bold;">[Citation {citation_num}]</a>'

    return re.sub(r'\[Citation (\d+)\]', replace_citation, summary_text)


def render_citation_card(citation: CitationGraph, category: str, graph: nx.MultiDiGraph, query_genes: List[str]):
    """Render a citation card with nodes, edges, and publications.

    Args:
        citation: Citation data
        category: Category name
        graph: Full knowledge graph
        query_genes: Input gene CURIEs for pathway display
    """
    anchor_id = f"citation_{category}_{citation.citation_id}"

    with st.container(border=True):
        st.markdown(f'<div id="{anchor_id}"></div>', unsafe_allow_html=True)
        st.markdown(f"**Citation {citation.citation_id}**: {citation.claim}")

        # Cited nodes
        if citation.node_ids:
            st.markdown("**Cited Nodes:**")
            for node_id in citation.node_ids[:10]:  # Limit display
                node_data = graph.nodes.get(node_id, {})
                label = node_data.get('label', node_id)
                gene_freq = node_data.get('gene_frequency', 0)
                st.markdown(f"- `{node_id}` ({label}) - Gene frequency: {gene_freq}")

        # Cited edges
        if citation.edge_ids:
            st.markdown("**Cited Edges:**")
            for edge_id in citation.edge_ids[:5]:  # Limit display
                st.markdown(f"- `{edge_id}`")

        # Publications
        if citation.publication_ids:
            st.markdown("**Publications:**")
            pub_links = []
            for pub_id in citation.publication_ids[:10]:  # Limit display
                link = _format_publication_link(pub_id)
                pub_links.append(link)
            st.markdown(" | ".join(pub_links), unsafe_allow_html=True)

        # View citation graph button
        if st.button(
            "View Citation Graph",
            key=f"view_citation_{category}_{citation.citation_id}",
            help="Visualize cited nodes and edges in interactive graph"
        ):
            # Store citation for viewing
            st.session_state.active_citation = {
                'citation': citation,
                'category': category
            }

    # If this citation is active, render the viewer
    if hasattr(st.session_state, 'active_citation'):
        active = st.session_state.active_citation
        if active['citation'].citation_id == citation.citation_id and active['category'] == category:
            from biograph_explorer.ui.citation_viewer import render_citation_viewer
            with st.container(border=True):
                st.markdown("##### Citation Graph Viewer")
                render_citation_viewer(citation, graph, query_genes=query_genes, category=category)


def _format_publication_link(pub_id: str) -> str:
    """Format publication ID as clickable HTML link.

    Args:
        pub_id: Publication ID (PMID:12345, PMC:PMC123456, DOI:...)

    Returns:
        HTML link string
    """
    if pub_id.startswith('PMID:'):
        pmid = pub_id.split(':')[1]
        return f'<a href="https://pubmed.ncbi.nlm.nih.gov/{pmid}" target="_blank">{pub_id}</a>'
    elif pub_id.startswith('PMC:'):
        pmc = pub_id.split(':')[1]
        return f'<a href="https://www.ncbi.nlm.nih.gov/pmc/articles/{pmc}" target="_blank">{pub_id}</a>'
    elif pub_id.startswith('DOI:'):
        doi = pub_id.split(':', 1)[1]
        return f'<a href="https://doi.org/{doi}" target="_blank">{pub_id}</a>'
    else:
        return pub_id
